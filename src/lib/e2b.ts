import { Sandbox } from "@e2b/code-interpreter";
import { writeFile } from "fs/promises";

export interface RenderRequest {
  script: string;
  prompt: string;
}

export async function renderManimVideo({
  script,
  prompt: _prompt,
}: RenderRequest): Promise<string> {
  let sandbox: Sandbox | null = null;

  try {
    // Create sandbox with extended timeout
    sandbox = await Sandbox.create("eureka-prototype-manim-ffmpeg", {
      timeoutMs: 300000, // 5 minutes
    });
    console.log("E2B sandbox created successfully");

    // Define paths
    const scriptPath = `/home/user/script.py`;
    const mediaDir = `/home/user/media`;
    const outputDir = `${mediaDir}/videos/script/480p15`;

    // Write the Manim script
    await sandbox.files.write(scriptPath, script);
    console.log("Manim script written to sandbox");

    // Run manim directly as a command
    const proc = await sandbox.commands.run(
      `manim ${scriptPath} MyScene --media_dir ${mediaDir} -ql --disable_caching`,
      {
        onStdout: (data) => {
          console.log(data);
        },
        onStderr: (data) => {
          console.log(data);
        },
      }
    );
    console.log("Manim process finished:", proc);
    // Verify success
    if (proc.exitCode !== 0) {
      throw new Error(
        `Manim failed with exit code ${proc.exitCode}\n${proc.stderr}`
      );
    }

    // List output directory

    const files = (await sandbox.files.list(outputDir)) as Array<{ name: string }>;
    console.log("Files in output directory:", files);

    const frameDir = `${mediaDir}/images/script/MyScene`;
    const frames = await sandbox.files.list(frameDir).catch(() => []);
    console.log("Frames:", frames);


    const videoFile = files.find((file) => file.name.endsWith(".mp4"));

    if (!videoFile) {
      throw new Error("No .mp4 video was generated by Manim");
    }

    const videoPath = `${outputDir}/${videoFile.name}`;

    console.log("Video file found:", videoPath);

    // Read file content as binary (E2B returns appropriate format by default)
    const videoData: unknown = await sandbox.files.read(videoPath);
    console.log(
      "E2B read type:",
      typeof videoData,
      videoData && typeof videoData === "object" && "byteLength" in (videoData as any)
        ? `byteLength=${(videoData as any).byteLength}`
        : ""
    );

    // Normalize to exact bytes without copying unrelated buffer regions
    let bytes: Uint8Array;
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(videoData as any)) {
      // Node Buffer -> Uint8Array view over the same bytes
      bytes = new Uint8Array(videoData as unknown as Buffer);
    } else if (Object.prototype.toString.call(videoData) === "[object ArrayBuffer]") {
      // ArrayBuffer case
      bytes = new Uint8Array(videoData as ArrayBuffer);
    } else if (
      videoData !== null &&
      typeof videoData === "object" &&
      "buffer" in (videoData as Record<string, unknown>) &&
      "byteOffset" in (videoData as Record<string, unknown>) &&
      "byteLength" in (videoData as Record<string, unknown>)
    ) {
      // A TypedArray-like object
      const v = videoData as unknown as {
        buffer: ArrayBuffer;
        byteOffset: number;
        byteLength: number;
      };
      bytes = new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
    } else if (
      videoData !== null &&
      typeof videoData === "object" &&
      "data" in (videoData as Record<string, unknown>) &&
      Array.isArray((videoData as Record<string, unknown>).data)
    ) {
      // Possibly a Buffer-like JSON shape { data: number[] }
      bytes = Uint8Array.from((videoData as { data: number[] }).data);
    } else if (typeof videoData === "string") {
      // Some environments may return file contents as a string.
      // Try to detect base64 and decode, otherwise treat as UTF-8 bytes.
      const s = videoData;
      const trimmed = s.replace(/\s+/g, "");
      const isLikelyBase64 = /^[A-Za-z0-9+/]+={0,2}$/.test(trimmed) && trimmed.length % 4 === 0;
      console.log(
        "String from E2B: length=",
        s.length,
        "trimmedLength=",
        trimmed.length,
        "isLikelyBase64=",
        isLikelyBase64,
        "prefix=",
        s.slice(0, 30)
      );
      if (isLikelyBase64) {
        const buf = Buffer.from(trimmed, "base64");
        // Sanity check that we didn't decode to empty; if empty, fall back to utf8
        bytes = buf.length > 0 ? new Uint8Array(buf) : new Uint8Array(Buffer.from(s, "utf8"));
      } else {
        bytes = new Uint8Array(Buffer.from(s, "utf8"));
      }
    } else {
      throw new Error(`Unexpected video data type: ${typeof videoData}`);
    }

    // Write bytes to a local temporary file to avoid base64 overhead
    const localPath = `/tmp/manim_video_${Date.now()}.mp4`;
    await writeFile(localPath, Buffer.from(bytes));
    console.log("Saved video to local path:", localPath);
    return localPath;
  } catch (error: any) {
    console.error("E2B sandbox rendering error:", error);
    throw new Error(`Failed to render Manim video: ${error.message}`);
  } finally {
    console.log("E2B sandbox will be closed by the framework");
  }
}
